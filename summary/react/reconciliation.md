## 재조정 ( Reconciliation )

하나의 트리를 가지고 다른 트리로 변환하기 위한 최소한의 연산 수를 구하는 알고리즘 문제를 풀기 위한 일반적인 해결법이 있고 이런 알고리즘도 n개의 엘리머트가 있는 트리에 대해 <code>O(n3)의 복잡도</code>를 가집니다.

이런 문제를 개선하기 위해 React는 O(n)복잡도의 휴리스틱 알고리즘을 구현했습니다.

- 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다.
- 개발자가 key prop을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해 줄 수 있다.

## 비교 알고리즘

두 개의 트리를 비교할 때, React는 두 엘리먼트의 루트(root)엘리먼트부터 비교합니다. 이후의 동작은 루트 엘리먼트의 타입에 따라 달라집니다.

### 엘리먼트 타입이 다른 경우

두 엘리먼트 타입이 다르면, React는 이전 트리를 버리고 완전히 새로운 트리를 구축.

- <code>\<a></code>에서 <code>\<img></code>로, <code>\<Article></code>에서 <code>\<Comment></code>로, 혹은 <code>\<Button></code>에서 <code>\<div></code>로 바뀌는 것 모두 트리 전체를 재구축하는 경우입니다.

### DOM엘리먼트의 타입이 같은 경우

같은 타입의 두 React DOM엘리먼트를 비교할 때, React는 두 엘리먼트의 속성을 확인하여, 동일한 내역은 유지하고 변경된 속성들만 갱신합니다. 예를 들어

```jsx
<div className="before" title="stuff" />
// className만 수정
<div className="after" title="stuff" />
```

DOM노드의 처리가 끝나면, React는 이어서 해당 노드의 자식들을 재귀적으로 처리합니다.

## Keys

목록이 추가되는 위치가 마지막이 아닌, 처음, 중간이라면 모든 리스트를 변경합니다. 이런 비효율은 문제가 될수 있고 이를 위해 <code>key</code>속성을 통해 React는 기존 트리와 이후 트리의 자식들이 일치하는지 확인합니다.

```jsx
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>

<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

이제 React는 '2014' key를 가진 엘리먼트가 새로 추가되었고, '2015'와 '2016' key를 가진 엘리먼트는 그저 이동만 하면 되는 것을 알 수 있습니다

## 고려사항

- 알고리즘은 다른 컴포넌트 타입을 갖는 종속 트리들의 일치 여부를 확인하지 않습니다. 매우 비슷한 결과를 출력하는 두 컴포넌트를 교체하고 있다면, 그 둘을 같은 타입으로 만드는 것이 나을 수도 있습니다.
- key는 반드시 변하지 않고, 예상 가능하며, 유일해야 합니다. 변하는 key(<code>Math.random()</code>으로 생성된 값)을 사용하면 컴포넌트 인스턴스와 DOM노드를 불필요하게 재생성하여 성능이 나빠지거나 자식 컴포넌트의 state가 유실될 수 있습니다.
